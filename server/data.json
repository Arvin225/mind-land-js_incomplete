{
  "toDoListNames": [
    {
      "listName": "执行",
      "id": "e26b"
    },
    {
      "listName": "待购",
      "id": "bb77"
    },
    {
      "listName": "项目",
      "id": "4a56"
    },
    {
      "listName": "备忘",
      "id": "4c66"
    }
  ],
  "toDoList": [
    {
      "id": "1",
      "content": "执行列表里的待办1",
      "done": true,
      "star": false,
      "del": false,
      "listId": "e26b",
      "listName": "执行"
    },
    {
      "id": "2",
      "content": "备忘列表里的待办1",
      "done": true,
      "star": true,
      "del": false,
      "listId": "4c66",
      "listName": "备忘"
    },
    {
      "id": "3",
      "content": "执行列表里的待办2",
      "done": false,
      "star": false,
      "del": false,
      "listId": "e26b",
      "listName": "执行"
    },
    {
      "id": "4",
      "content": "待购列表里的待办1",
      "done": false,
      "star": true,
      "del": false,
      "listId": "bb77",
      "listName": "待购"
    },
    {
      "id": "5",
      "content": "待购列表里的待办2",
      "done": false,
      "star": true,
      "del": true,
      "listId": "bb77",
      "listName": "待购"
    },
    {
      "id": "6",
      "content": "项目列表里的待办1",
      "done": false,
      "star": false,
      "del": false,
      "listId": "4a56",
      "listName": "项目"
    },
    {
      "id": "63c2",
      "content": "没有待办吗",
      "done": false,
      "star": false,
      "del": false,
      "listId": "e26b",
      "listName": "执行"
    },
    {
      "id": "c298",
      "content": "tet",
      "done": false,
      "star": false,
      "del": true,
      "listId": "0971",
      "listName": "测试"
    },
    {
      "id": "7095",
      "content": "bchds",
      "done": false,
      "star": false,
      "del": true,
      "listId": "0971",
      "listName": "测试"
    },
    {
      "id": "5199",
      "content": "nz",
      "done": false,
      "star": false,
      "del": true,
      "listId": "0971",
      "listName": "测试"
    },
    {
      "id": "660a",
      "content": "ajsdfkas",
      "done": false,
      "star": false,
      "del": true,
      "listId": "0971",
      "listName": "测试"
    },
    {
      "id": "5b08",
      "content": "bjcvzxcv",
      "done": false,
      "star": false,
      "del": true,
      "listId": "0971",
      "listName": "测试"
    },
    {
      "id": "6a2f",
      "content": "asdfasdf",
      "done": false,
      "star": false,
      "del": true,
      "listId": "0971",
      "listName": "测试"
    },
    {
      "id": "7fe1",
      "content": "xzcvzx",
      "done": false,
      "star": false,
      "del": true,
      "listId": "0971",
      "listName": "测试"
    },
    {
      "id": "15b7",
      "content": "asdfasdfadsfasdf",
      "done": false,
      "star": false,
      "del": true,
      "listId": "90cf",
      "listName": "测试"
    },
    {
      "id": "2a5c",
      "content": "adsf",
      "done": false,
      "star": false,
      "del": true,
      "listId": "90cf",
      "listName": "测试"
    },
    {
      "id": "8bb0",
      "content": "asdfasdf",
      "done": false,
      "star": false,
      "del": true,
      "listId": "90cf",
      "listName": "测试"
    },
    {
      "id": "a0de",
      "content": "asdf",
      "done": false,
      "star": false,
      "del": true,
      "listId": "",
      "listName": ""
    },
    {
      "id": "27d8",
      "content": "asdf",
      "done": false,
      "star": false,
      "del": true,
      "listId": "b0b3",
      "listName": "cc"
    },
    {
      "id": "58b8",
      "content": "zxcv",
      "done": false,
      "star": false,
      "del": true,
      "listId": "b0b3",
      "listName": "cc"
    },
    {
      "id": "178a",
      "content": "wa",
      "done": false,
      "star": false,
      "del": true,
      "listId": "b0b3",
      "listName": "cc"
    },
    {
      "id": "54e8",
      "content": "faf",
      "done": false,
      "star": false,
      "del": true,
      "listId": "",
      "listName": ""
    },
    {
      "id": "e3fe",
      "content": "afsd",
      "done": false,
      "star": false,
      "del": true,
      "listId": "",
      "listName": ""
    },
    {
      "id": "8eda",
      "content": "afds",
      "done": false,
      "star": false,
      "del": true,
      "listId": "",
      "listName": ""
    },
    {
      "id": "3599",
      "content": "fasd",
      "done": false,
      "star": false,
      "del": true,
      "listId": "",
      "listName": ""
    },
    {
      "id": "296c",
      "content": "asdfasd",
      "done": false,
      "star": false,
      "del": true,
      "listId": "",
      "listName": ""
    },
    {
      "id": "9077",
      "content": "adsf",
      "done": false,
      "star": false,
      "del": true,
      "listId": "",
      "listName": ""
    },
    {
      "id": "0ec1",
      "content": "adsf",
      "done": false,
      "star": false,
      "del": true,
      "listId": "",
      "listName": ""
    },
    {
      "id": "a6e6",
      "content": "agdfg",
      "done": false,
      "star": false,
      "del": true,
      "listId": "",
      "listName": ""
    },
    {
      "id": "b587",
      "content": "dfgdf",
      "done": false,
      "star": false,
      "del": true,
      "listId": "",
      "listName": ""
    },
    {
      "id": "61de",
      "content": "sdafasdf",
      "done": false,
      "star": false,
      "del": true,
      "listId": "",
      "listName": ""
    },
    {
      "id": "56ca",
      "content": "fds",
      "done": false,
      "star": false,
      "del": true,
      "listId": "",
      "listName": ""
    },
    {
      "id": "f514",
      "content": "sdfas",
      "done": false,
      "star": false,
      "del": true,
      "listId": "",
      "listName": ""
    },
    {
      "id": "cd13",
      "content": "dffg",
      "done": false,
      "star": false,
      "del": true,
      "listId": "",
      "listName": ""
    },
    {
      "id": "a94c",
      "content": "sdfg",
      "done": false,
      "star": false,
      "del": true,
      "listId": "",
      "listName": ""
    },
    {
      "id": "ab41",
      "content": "dfsadf",
      "done": false,
      "star": false,
      "del": true,
      "listId": "",
      "listName": ""
    },
    {
      "id": "6187",
      "content": "dfa",
      "done": false,
      "star": false,
      "del": true,
      "listId": "",
      "listName": ""
    }
  ],
  "cards": [
    {
      "id": "b327",
      "content": "<p>Java开启一个线程后，JVM会为其分配一个Java虚拟机栈，栈里面有栈帧，栈帧里面包含方法执行时的局部变量、方法参数、返回地址等</p><p>#Java/JVM</p><p></p>",
      "builtOrDelTime": "创建于 2024-10-02 13:53",
      "statistics": {
        "builtTime": "2024-10-02 13:53",
        "updateTime": "2024-10-02 13:53",
        "words": 85
      },
      "tags": [],
      "del": true
    },
    {
      "id": "8049",
      "content": "<ol><li>B+树索引适用于下边这些情况：全值匹配匹配左边的列匹配范围值精确匹配某一列并范围匹配另外一列用于排序用于分组</li><li>在使用索引时需要注意下边这些事项：只为用于搜索、排序或分组的列创建索引为列的基数大的列创建索引索引列的类型尽量小可以只对字符串值的前缀建立索引只有索引列在比较表达式中单独出现才可以适用索引为了尽可能少的让聚簇索引发生页面分裂和记录移位的情况，建议让主键拥有AUTO_INCREMENT属性。定位并删除表中的重复和冗余索引尽量使用覆盖索引进行查询，避免回表带来的性能损耗。</li></ol><p> /MySQL/B+Tree </p>",
      "builtOrDelTime": "创建于 2024-10-02 14:21",
      "statistics": {
        "builtTime": "2024-10-02 14:21",
        "updateTime": "2024-10-02 14:21",
        "words": 259
      },
      "tags": [],
      "del": true
    },
    {
      "id": "8b37",
      "content": "<p><strong>基于规则的优化</strong></p><ul><li>语句重写规则</li><li>IN子查询的优化如果IN子查询符合转换为semi-join的条件，查询优化器会优先把该子查询转换为semi-join，然后再考虑下边5种执行半连接的策略中哪个成本最低：Table pulloutDuplicateWeedoutLooseScanMaterializationFirstMatch选择成本最低的那种执行策略来执行子查询。如果IN子查询不符合转换为semi-join的条件，那么查询优化器会从下边两种策略中找出一种成本更低的方式执行子查询：先将子查询物化之后再执行查询执行IN to EXISTS转换</li></ul><p>/MySQL/QueryOptimizing </p>",
      "builtOrDelTime": "创建于 2024-10-02 14:21",
      "statistics": {
        "builtTime": "2024-10-02 14:21",
        "updateTime": "2024-10-02 14:21",
        "words": 298
      },
      "tags": [],
      "del": true
    },
    {
      "id": "42af",
      "content": "<p>一张表有N个索引</p><ul><li>每个索引分为两个段：非叶子节点段（目录页集合）、叶子节点段（数据页集合）每个段额外维护三个链表：空闲（Free）区的 XEDS Entry 链表有剩余空间（Not_Full）区的 XEDS Entry 链表爆满（Full）区的 XEDS Entry 链表</li><li>另外表空间还要维护碎片区的三个链表Free 空闲区的 XEDS Entry 链表Free_Frag 有剩余空间区的 XEDS Entry 链表Full 爆满区的 XEDS Entry 链表</li></ul><p> /MySQL/TableSpace</p>",
      "builtOrDelTime": "创建于 2024-10-02 14:22",
      "statistics": {
        "builtTime": "2024-10-02 14:22",
        "updateTime": "2024-10-02 14:22",
        "words": 253
      },
      "tags": [],
      "del": true
    },
    {
      "id": "c956",
      "content": "<p>InnoDB中，所有非主键索引，最终都会回到聚簇索引，称为 “回表”</p><p>  </p><p> /MySQL/B+Tree </p>",
      "builtOrDelTime": "创建于 2024-10-02 14:22",
      "statistics": {
        "builtTime": "2024-10-02 14:22",
        "updateTime": "2024-10-02 14:22",
        "words": 79
      },
      "tags": [],
      "del": true
    },
    {
      "id": "5286",
      "content": "<p><strong>基于成本的优化</strong></p><p>1.全表扫描的成本构成：</p><ul><li>I/O成本：占用的字节数 ➗ 单页大小（16KB）✖ 1.0 ➕ 1.1</li><li>CPU成本：记录数 ✖ 0.2 ➕1.0</li></ul><p><br></p><p>2.一个二级索引条件单次查询的成本构成：</p><ul><li>对于索引表： I/O成本：条件中的范围（区间）数 ✖ 1.0CPU成本：条件中所有区间的记录数 ✖ 0.2 ➕ 0.01</li><li>回表时：I/O成本：条件中所有区间的记录数 ✖ 1.0 （每次回表操作都相当于访问一次页面）</li><li>其余条件的匹配：CPU成本：条件中所有区间的记录数 ✖ 0.2</li></ul><p><br></p><ol><li>查询优化的步骤：基于1和2，即分别计算全表扫描、各个索引条件的查询成本，对比找出代价最低的作为最终执行计划</li><li>连接查询的成本 ＝ 单次访问驱动表的成本 ➕ 驱动表扇出数 ✖ 单次访问被驱动表的成本</li><li>连接查询的优化步骤：</li></ol><p> &nbsp; - 对于两表的连接：</p><p> &nbsp; - 对于多表的连接：</p><p>/MySQL/QueryOptimizing</p>",
      "builtOrDelTime": "创建于 2024-10-02 14:22",
      "statistics": {
        "builtTime": "2024-10-02 14:22",
        "updateTime": "2024-10-02 14:22",
        "words": 404
      },
      "tags": [],
      "del": true
    },
    {
      "id": "6c0b",
      "content": "<p>二叉搜索树的效率：</p><ul><li>二叉搜索树的查找操作天然地实现了二分查找，因此时间复杂度为 O(logN)</li><li>又因为插入和删除操作依赖查找操作，因此插入和删除的时间复杂度也为 O(logN)</li></ul><p> /DS&A/BinaryTree/BinarySearchTree </p>",
      "builtOrDelTime": "创建于 2024-10-02 14:22",
      "statistics": {
        "builtTime": "2024-10-02 14:22",
        "updateTime": "2024-10-02 14:22",
        "words": 127
      },
      "tags": [],
      "del": true
    },
    {
      "id": "f304",
      "content": "<p>插入一个节点时：</p><ul><li>按照 “小于看左，大于看右” 的操作找到一个空位插入即可（不严谨地说插入后该节点就成了这颗树的一个叶子节点）</li><li>要注意的是二叉搜索树中不能有重复的节点，因此插入时遇到值相等的节点直接终止插入</li></ul><p> /DS&A/BinaryTree/BinarySearchTree </p>",
      "builtOrDelTime": "创建于 2024-10-02 14:22",
      "statistics": {
        "builtTime": "2024-10-02 14:22",
        "updateTime": "2024-10-02 14:22",
        "words": 142
      },
      "tags": [],
      "del": true
    },
    {
      "id": "19cf",
      "content": "<p>红黑性质：</p><ol><li>所有节点不是黑色就是红色</li><li>根节点是黑色的</li><li>每个叶子节点都是黑色的（为了处理边界问题，空节点也被视为叶子节点，即空节点都是黑色的）</li><li>红色节点的两个子节点必须都是黑色的（红红不相邻）</li><li>对于每个节点，到其各个叶子节点经过的黑色节点的数量相等</li></ol><p>/DS&A/BlackRedTree </p>",
      "builtOrDelTime": "创建于 2024-10-02 14:22",
      "statistics": {
        "builtTime": "2024-10-02 14:22",
        "updateTime": "2024-10-02 14:22",
        "words": 146
      },
      "tags": [],
      "del": true
    },
    {
      "id": "60a5",
      "content": "<p>快速排序和归并排序</p><ul><li>快速排序和归并排序体现的都是分治思想，时间复杂度都是O(nlogn)</li><li>区别快速排序是分的时候排序，最后只管合并左右已经排好序的左右子序列归并排序是归的时候排序，先分，回溯的时候再一一比较排序，比较的是各子序列的首元素，小的（大的）则放到辅助数组中，引入了额外的数组空间，空间复杂度为</li></ul><p> /DS&A/Sorting</p>",
      "builtOrDelTime": "创建于 2024-10-02 14:22",
      "statistics": {
        "builtTime": "2024-10-02 14:22",
        "updateTime": "2024-10-02 14:22",
        "words": 169
      },
      "tags": [],
      "del": true
    },
    {
      "id": "c6bb",
      "content": "<p>#Java/SpringBoot </p><p>凡带starter的包，SpringBoot都对其进行了整合，意味着可在yml文件中进行属性配置</p>",
      "builtOrDelTime": "创建于 2024-10-02 14:23",
      "statistics": {
        "builtTime": "2024-10-02 14:23",
        "updateTime": "2024-10-02 14:23",
        "words": 66
      },
      "tags": [],
      "del": true
    },
    {
      "id": "7262",
      "content": "<p> #Java/SpringBoot </p><p>给类加上 @Configuration 注解变成配置类，一般是想在SpringBoot启动时顺带初始化某些东西，比如添加某些必要的对象进IoC容器，以便后续使用</p>",
      "builtOrDelTime": "创建于 2024-10-02 14:23",
      "statistics": {
        "builtTime": "2024-10-02 14:23",
        "updateTime": "2024-10-02 14:23",
        "words": 99
      },
      "tags": [],
      "del": true
    },
    {
      "id": "7751",
      "content": "<p>原子类的内部是用Unsafe类实现各种原子的操作，而Unsafe结合了CAS技术，且其对对象属性值的修改需要借助该属性相对于所属对象在内存中的偏移量offset，同时由于CAS的性质，该属性需要用volatile修饰，防止JIT对其缓存优化</p><p>#Java/JUC </p>",
      "builtOrDelTime": "创建于 2024-10-02 14:23",
      "statistics": {
        "builtTime": "2024-10-02 14:23",
        "updateTime": "2024-10-02 14:23",
        "words": 131
      },
      "tags": [],
      "del": true
    },
    {
      "id": "9fa4",
      "content": "<p>基于网络的应用程序采用React或Angular等技术，移动应用程序采用React Native或Flutter等技术，是构建跨平台应用程序的热门选择。对于桌面应用，Electron是一个流行的框架，它允许你用网络技术创建跨平台的桌面应用。 </p><p>#AppDev</p>",
      "builtOrDelTime": "创建于 2024-10-12 13:17",
      "statistics": {
        "builtTime": "2024-10-12 13:17",
        "updateTime": "2024-10-12 13:17",
        "words": 129
      },
      "tags": [],
      "del": true
    },
    {
      "id": "1c56",
      "content": "<p>原子类的内部是用Unsafe类实现各种原子的操作，而Unsafe结合了CAS技术，且其对对象属性值的修改需要借助该属性相对于所属对象在内存中的偏移量offset，同时由于CAS的性质，该属性需要用volatile修饰，防止JIT对其缓存优化</p><p>#Java/JUC </p>",
      "builtOrDelTime": "删除于 2024-10-12 13:33",
      "statistics": {
        "builtTime": "2024-10-12 13:17",
        "updateTime": "2024-10-12 13:17",
        "words": 131
      },
      "tags": [
        "7d80"
      ],
      "del": true
    },
    {
      "id": "c55f",
      "content": "<p>Java开启一个线程后，JVM会为其分配一个Java虚拟机栈，栈里面有栈帧，栈帧里面包含方法执行时的局部变量、方法参数、返回地址等</p><p>#Java/JVM</p><p>#Java/JUC</p>",
      "builtOrDelTime": "删除于 2024-10-12 18:36",
      "statistics": {
        "builtTime": "2024-10-12 14:07",
        "updateTime": "2024-10-12 14:07",
        "words": 85
      },
      "tags": [
        "cd89"
      ],
      "del": true
    },
    {
      "id": "948b",
      "content": "<p><strong>基于规则的优化</strong></p><ul><li>语句重写规则</li><li>IN子查询的优化如果IN子查询符合转换为semi-join的条件，查询优化器会优先把该子查询转换为semi-join，然后再考虑下边5种执行半连接的策略中哪个成本最低：Table pulloutDuplicateWeedoutLooseScanMaterializationFirstMatch选择成本最低的那种执行策略来执行子查询。如果IN子查询不符合转换为semi-join的条件，那么查询优化器会从下边两种策略中找出一种成本更低的方式执行子查询：先将子查询物化之后再执行查询执行IN to EXISTS转换</li></ul><p>#CS/MySQL/QueryOptimizing </p>",
      "builtOrDelTime": "删除于 2024-10-12 18:34",
      "statistics": {
        "builtTime": "2024-10-12 16:22",
        "updateTime": "2024-10-12 16:22",
        "words": 298
      },
      "tags": [
        "1304"
      ],
      "del": true
    },
    {
      "id": "06b6",
      "content": "<p>#hello/world nzjxcASD</p>",
      "builtOrDelTime": "删除于 2024-10-12 16:23",
      "statistics": {
        "builtTime": "2024-10-12 16:23",
        "updateTime": "2024-10-12 16:23",
        "words": 21
      },
      "tags": [
        "a6be"
      ],
      "del": true
    },
    {
      "id": "1df0",
      "content": "<p><strong>synchronized 加锁、重入、解锁过程（以轻量级锁为原点）：</strong></p><p>初始状态：加锁的方法对应的栈帧中生成一个 lock record 结构，其中第一部分记录所在 lock record 地址 & 轻量级锁编号00，第二部分记录锁对象地址</p><ul><li>加锁：读取锁对象对象头中 mark word 的值，判断是否加锁，未加锁则通过 CAS技术 交换 lock record 中记录的所在 lock record 地址 & 轻量级锁编号00，已加锁则申请 Monitor，lock record 第一部分改为该Monitor的地址&重量级锁编号10，接着系统会将锁对象的 mark word 值改为该 Monitor 的地址，修改 Monitor 中的 owner 属性的值为持有锁的线程的栈帧，多核 CPU 下当前线程会以自旋的方式尝试加锁，自旋一定次数后若仍然无法加锁则切换当前线程的上下文将其加入 entryList 阻塞</li><li>锁重入：一个线程中的其他方法若也要加相同的锁，则其栈帧仍会生成一个 lock record 结构，并检查锁对象的 mark word，发现已上锁且持有者为当前线程的其他栈帧，则将 lock record 第一部分置为 null，解锁时重置该 lock record 即可；若重入过多，则轻量级锁会被优化成偏向锁，锁对象中的 mark word 值被改写为 Biased 状态时的值，其中保存了当前线程的线程id，倒数第三位改为1表示开启偏向锁，解锁时不做任何操作，mark word值不变，线程id仍然保留（因此 “偏向”）</li><li>解锁：尝试直接交换锁对象当前 mark word 的值，交换成功则解锁成功，否则发生了锁膨胀，需进行重量级锁的解锁，即通过锁对象当前 mark word 中的Monitor地址找到 Monitor，再将 Monitor 的 owner 属性值置空，而后唤醒 entryList 中等待的线程</li></ul><p>Mark Word 有五种状态</p><p>#Java/JUC</p>",
      "builtOrDelTime": "删除于 2024-10-12 20:38",
      "statistics": {
        "builtTime": "2024-10-12 20:37",
        "updateTime": "2024-10-12 20:37",
        "words": 842
      },
      "tags": [
        "d9a9"
      ],
      "del": true
    },
    {
      "id": "e961",
      "content": "<p><strong>synchronized 加锁、重入、解锁过程（以轻量级锁为原点）：</strong></p><p>初始状态：加锁的方法对应的栈帧中生成一个 lock record 结构，其中第一部分记录所在 lock record 地址 & 轻量级锁编号00，第二部分记录锁对象地址</p><ul><li>加锁：读取锁对象对象头中 mark word 的值，判断是否加锁，未加锁则通过 CAS技术 交换 lock record 中记录的所在 lock record 地址 & 轻量级锁编号00，已加锁则申请 Monitor，lock record 第一部分改为该Monitor的地址&重量级锁编号10，接着系统会将锁对象的 mark word 值改为该 Monitor 的地址，修改 Monitor 中的 owner 属性的值为持有锁的线程的栈帧，多核 CPU 下当前线程会以自旋的方式尝试加锁，自旋一定次数后若仍然无法加锁则切换当前线程的上下文将其加入 entryList 阻塞</li><li>锁重入：一个线程中的其他方法若也要加相同的锁，则其栈帧仍会生成一个 lock record 结构，并检查锁对象的 mark word，发现已上锁且持有者为当前线程的其他栈帧，则将 lock record 第一部分置为 null，解锁时重置该 lock record 即可；若重入过多，则轻量级锁会被优化成偏向锁，锁对象中的 mark word 值被改写为 Biased 状态时的值，其中保存了当前线程的线程id，倒数第三位改为1表示开启偏向锁，解锁时不做任何操作，mark word值不变，线程id仍然保留（因此 “偏向”）</li><li>解锁：尝试直接交换锁对象当前 mark word 的值，交换成功则解锁成功，否则发生了锁膨胀，需进行重量级锁的解锁，即通过锁对象当前 mark word 中的Monitor地址找到 Monitor，再将 Monitor 的 owner 属性值置空，而后唤醒 entryList 中等待的线程</li></ul><p>Mark Word 有五种状态</p><p>#Java/JUC</p>",
      "builtOrDelTime": "删除于 2024-10-12 20:44",
      "statistics": {
        "builtTime": "2024-10-12 20:44",
        "updateTime": "2024-10-12 20:44",
        "words": 842
      },
      "tags": [
        "da97"
      ],
      "del": true
    },
    {
      "id": "46bc",
      "content": "<p><br></p><p><strong>synchronized 加锁、重入、解锁过程（以轻量级锁为原点）：</strong></p><p>初始状态：加锁的方法对应的栈帧中生成一个 lock record 结构，其中第一部分记录所在 lock record 地址 & 轻量级锁编号00，第二部分记录锁对象地址</p><ul><li>加锁：读取锁对象对象头中 mark word 的值，判断是否加锁，未加锁则通过 CAS技术 交换 lock record 中记录的所在 lock record 地址 & 轻量级锁编号00，已加锁则申请 Monitor，lock record 第一部分改为该Monitor的地址&重量级锁编号10，接着系统会将锁对象的 mark word 值改为该 Monitor 的地址，修改 Monitor 中的 owner 属性的值为持有锁的线程的栈帧，多核 CPU 下当前线程会以自旋的方式尝试加锁，自旋一定次数后若仍然无法加锁则切换当前线程的上下文将其加入 entryList 阻塞</li><li>锁重入：一个线程中的其他方法若也要加相同的锁，则其栈帧仍会生成一个 lock record 结构，并检查锁对象的 mark word，发现已上锁且持有者为当前线程的其他栈帧，则将 lock record 第一部分置为 null，解锁时重置该 lock record 即可；若重入过多，则轻量级锁会被优化成偏向锁，锁对象中的 mark word 值被改写为 Biased 状态时的值，其中保存了当前线程的线程id，倒数第三位改为1表示开启偏向锁，解锁时不做任何操作，mark word值不变，线程id仍然保留（因此 “偏向”）</li><li>解锁：尝试直接交换锁对象当前 mark word 的值，交换成功则解锁成功，否则发生了锁膨胀，需进行重量级锁的解锁，即通过锁对象当前 mark word 中的Monitor地址找到 Monitor，再将 Monitor 的 owner 属性值置空，而后唤醒 entryList 中等待的线程</li></ul><p>Mark Word 有五种状态</p><p>#Java/JUC#</p>",
      "builtOrDelTime": "删除于 2024-10-12 20:48",
      "statistics": {
        "builtTime": "2024-10-12 20:48",
        "updateTime": "2024-10-12 20:48",
        "words": 844
      },
      "tags": [
        "1e17"
      ],
      "del": true
    },
    {
      "id": "a8c0",
      "content": "<p><strong>synchronized 加锁、重入、解锁过程（以轻量级锁为原点）：</strong></p><p>初始状态：加锁的方法对应的栈帧中生成一个 lock record 结构，其中第一部分记录所在 lock record 地址 & 轻量级锁编号00，第二部分记录锁对象地址</p><ul><li>加锁：读取锁对象对象头中 mark word 的值，判断是否加锁，未加锁则通过 CAS技术 交换 lock record 中记录的所在 lock record 地址 & 轻量级锁编号00，已加锁则申请 Monitor，lock record 第一部分改为该Monitor的地址&重量级锁编号10，接着系统会将锁对象的 mark word 值改为该 Monitor 的地址，修改 Monitor 中的 owner 属性的值为持有锁的线程的栈帧，多核 CPU 下当前线程会以自旋的方式尝试加锁，自旋一定次数后若仍然无法加锁则切换当前线程的上下文将其加入 entryList 阻塞</li><li>锁重入：一个线程中的其他方法若也要加相同的锁，则其栈帧仍会生成一个 lock record 结构，并检查锁对象的 mark word，发现已上锁且持有者为当前线程的其他栈帧，则将 lock record 第一部分置为 null，解锁时重置该 lock record 即可；若重入过多，则轻量级锁会被优化成偏向锁，锁对象中的 mark word 值被改写为 Biased 状态时的值，其中保存了当前线程的线程id，倒数第三位改为1表示开启偏向锁，解锁时不做任何操作，mark word值不变，线程id仍然保留（因此 “偏向”）</li><li>解锁：尝试直接交换锁对象当前 mark word 的值，交换成功则解锁成功，否则发生了锁膨胀，需进行重量级锁的解锁，即通过锁对象当前 mark word 中的Monitor地址找到 Monitor，再将 Monitor 的 owner 属性值置空，而后唤醒 entryList 中等待的线程</li></ul><p>Mark Word 有五种状态</p><p>#Java/JUC</p>",
      "builtOrDelTime": "创建于 2024-10-12 20:48",
      "statistics": {
        "builtTime": "2024-10-12 20:48",
        "updateTime": "2024-10-12 20:48",
        "words": 842
      },
      "tags": [],
      "del": true
    },
    {
      "id": "9cc3",
      "content": "<p><strong>synchronized 加锁、重入、解锁过程（以轻量级锁为原点）：</strong></p><p>初始状态：加锁的方法对应的栈帧中生成一个 lock record 结构，其中第一部分记录所在 lock record 地址 & 轻量级锁编号00，第二部分记录锁对象地址</p><ul><li>加锁：读取锁对象对象头中 mark word 的值，判断是否加锁，未加锁则通过 CAS技术 交换 lock record 中记录的所在 lock record 地址 & 轻量级锁编号00，已加锁则申请 Monitor，lock record 第一部分改为该Monitor的地址&重量级锁编号10，接着系统会将锁对象的 mark word 值改为该 Monitor 的地址，修改 Monitor 中的 owner 属性的值为持有锁的线程的栈帧，多核 CPU 下当前线程会以自旋的方式尝试加锁，自旋一定次数后若仍然无法加锁则切换当前线程的上下文将其加入 entryList 阻塞</li><li>锁重入：一个线程中的其他方法若也要加相同的锁，则其栈帧仍会生成一个 lock record 结构，并检查锁对象的 mark word，发现已上锁且持有者为当前线程的其他栈帧，则将 lock record 第一部分置为 null，解锁时重置该 lock record 即可；若重入过多，则轻量级锁会被优化成偏向锁，锁对象中的 mark word 值被改写为 Biased 状态时的值，其中保存了当前线程的线程id，倒数第三位改为1表示开启偏向锁，解锁时不做任何操作，mark word值不变，线程id仍然保留（因此 “偏向”）</li><li>解锁：尝试直接交换锁对象当前 mark word 的值，交换成功则解锁成功，否则发生了锁膨胀，需进行重量级锁的解锁，即通过锁对象当前 mark word 中的Monitor地址找到 Monitor，再将 Monitor 的 owner 属性值置空，而后唤醒 entryList 中等待的线程</li></ul><p>Mark Word 有五种状态</p><p>#Java/JUC</p>",
      "builtOrDelTime": "删除于 2024-10-12 20:51",
      "statistics": {
        "builtTime": "2024-10-12 20:50",
        "updateTime": "2024-10-12 20:50",
        "words": 842
      },
      "tags": [
        "d856"
      ],
      "del": true
    },
    {
      "id": "6cbe",
      "content": "<p>Java开启一个线程后，JVM会为其分配一个Java虚拟机栈，栈里面有栈帧，栈帧里面包含方法执行时的局部变量、方法参数、返回地址等</p><p>#Java/JVM</p><p>#Java/JUC</p>",
      "builtOrDelTime": "创建于 2024-10-12 22:08",
      "statistics": {
        "builtTime": "2024-10-12 22:08",
        "updateTime": "2024-10-12 22:08",
        "words": 85
      },
      "tags": [],
      "del": true
    },
    {
      "id": "8460",
      "content": "<p>Java开启一个线程后，JVM会为其分配一个Java虚拟机栈，栈里面有栈帧，栈帧里面包含方法执行时的局部变量、方法参数、返回地址等</p><p>#Java/JVM</p><p>#Java/JUC</p>",
      "builtOrDelTime": "删除于 2024-10-12 22:14",
      "statistics": {
        "builtTime": "2024-10-12 22:14",
        "updateTime": "2024-10-12 22:14",
        "words": 85
      },
      "tags": [
        "8d77",
        "b957"
      ],
      "del": true
    }
  ],
  "tags": []
}